local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommF = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CommF_")
local LocalPlayer = Players.LocalPlayer
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local PlaceId = game.PlaceId


local WindUI = loadstring(game:HttpGet(
    "https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"
))()

-- å»ºç«‹è¦–çª—ï¼ˆå·²æ•´åˆ OpenButtonï¼‰
local Window = WindUI:CreateWindow({
    Title = "Xu-hub",
    Icon = "user-check",
    Author = "by xuez1025",
    Folder = "Xu-Hub",
    Size = UDim2.fromOffset(600, 400),
    Transparent = true,
    Theme = "Dark",

    -- âœ… ä½¿ç”¨è€…é ­åƒ / Profile
User = {
    Enabled = true,
    Anonymous = false,
    Callback = function()
        WindUI:Notify({
            Title = LocalPlayer.Name,
            Content = "ID: " .. LocalPlayer.UserId,
            Duration = 3
        })
    end
},

    -- âœ… è¦–è¦º / ä»‹é¢è¨­å®š
    Acrylic = false,
    HideSearchBar = false,
    SideBarWidth = 200,

    -- ğŸ”½ ç¸®å°å¾Œé¡¯ç¤ºçš„æµ®å‹•æŒ‰éˆ•
    OpenButton = {
        Title = "Xu-hub",
        CornerRadius = UDim.new(1, 0), -- å®Œå…¨åœ“å½¢
        StrokeThickness = 3,
        Enabled = true,
        OnlyMobile = false,
        Draggable = true,
        OnlyIcon = false,

        Color = ColorSequence.new(
    Color3.fromHex("#7F00FF"),
    Color3.fromHex("#00C6FF")
),
    }
})

        -- ================= æ ¸å¿ƒ ESP åŠŸèƒ½ =================
        local LocalPlayer = Players.LocalPlayer

        ESP_ENABLED = false
        local ESP_COLOR = Color3.fromRGB(30,30,30)
        local TEXT_COLOR = Color3.fromRGB(255,255,255)

        local function createESP(player)
            if player == LocalPlayer then return end
            if not player.Character then return end
            if player.Character:FindFirstChild("ESP_Highlight") then return end

            local h = Instance.new("Highlight")
            h.Name = "ESP_Highlight"
            h.FillColor = ESP_COLOR
            h.OutlineColor = Color3.fromRGB(255,255,255)
            h.FillTransparency = 0.2
            h.OutlineTransparency = 0
            h.Adornee = player.Character
            h.Parent = player.Character

            local head = player.Character:FindFirstChild("Head")
            if not head then return end

            local bill = Instance.new("BillboardGui")
            bill.Name = "ESP_Billboard"
			bill.Size = UDim2.fromOffset(140,48)
			bill.StudsOffset = Vector3.new(0,2.6,0)
            bill.AlwaysOnTop = true
            bill.Parent = head

            local text = Instance.new("TextLabel", bill)
            text.Name = "Info"
            text.Position = UDim2.new(0,0,0,0)
            text.BackgroundTransparency = 1
            text.TextColor3 = TEXT_COLOR
            text.TextStrokeTransparency = 0
            text.Font = Enum.Font.SourceSansBold
            text.TextYAlignment = Enum.TextYAlignment.Top
            text.Text = player.Name
			text.Size = UDim2.new(1, -8, 0.65, 0)
			text.Position = UDim2.new(0,4,0,2)
			text.TextScaled = true
			text.TextWrapped = true
			text.TextSize = 18
			text.TextXAlignment = Enum.TextXAlignment.Center

            local barBG = Instance.new("Frame", bill)
            barBG.Name = "HP_Background"
			barBG.Size = UDim2.new(0.9,0,0.12,0)
			barBG.Position = UDim2.new(0.05,0,0.78,0)
            barBG.BackgroundColor3 = Color3.fromRGB(50,50,50)
            barBG.BorderSizePixel = 0

            local barFG = Instance.new("Frame", barBG)
            barFG.Name = "HP_Fill"
            barFG.Size = UDim2.new(1,0,1,0)
            barFG.Position = UDim2.new(0,0,0,0)
            barFG.BackgroundColor3 = Color3.fromRGB(0,255,0)
            barFG.BorderSizePixel = 0
        end

        local function removeESP(player)
            if player == LocalPlayer then return end
            if not player.Character then return end
            local h = player.Character:FindFirstChild("ESP_Highlight")
            if h then h:Destroy() end
            local head = player.Character:FindFirstChild("Head")
            if head then
                local bill = head:FindFirstChild("ESP_Billboard")
                if bill then bill:Destroy() end
            end
        end

        local function updateESP()
		if not ESP_ENABLED or not LocalPlayer.Character then return end
		local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		if not myHRP then return end

		for _, p in ipairs(Players:GetPlayers()) do
		if p ~= LocalPlayer and p.Character then
		local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
		local hrp = p.Character:FindFirstChild("HumanoidRootPart")
		local head = p.Character:FindFirstChild("Head")
		if humanoid and hrp and head then
		local bill = head:FindFirstChild("ESP_Billboard")
		if bill then
		local info = bill:FindFirstChild("Info")
		local barFG = bill:FindFirstChild("HP_Background") and bill.HP_Background:FindFirstChild("HP_Fill")
		if info then
		local dist = math.floor((myHRP.Position - hrp.Position).Magnitude)
		info.Text = string.format(
		"%s\nHP: %d | %dm",
		p.Name,
		math.floor(humanoid.Health),
		dist
		)
		end
		if barFG then
		local healthRatio = math.clamp(humanoid.Health / humanoid.MaxHealth,0,1)
		if healthRatio > 0.6 then
		barFG.BackgroundColor3 = Color3.fromRGB(0,255,0)
		elseif healthRatio > 0.3 then
		barFG.BackgroundColor3 = Color3.fromRGB(255,255,0)
		else
		barFG.BackgroundColor3 = Color3.fromRGB(255,0,0)
		end
		barFG.Size = UDim2.new(healthRatio,0,1,0)
					end
				end
			end
		end
	end
end

        -- æ¯å¹€æ›´æ–°
        RunService.RenderStepped:Connect(updateESP)

        -- ç©å®¶äº‹ä»¶
        local function setupPlayerESP(p)
            if p == LocalPlayer then return end
            p.CharacterAdded:Connect(function()
                task.wait(0.2)
                if ESP_ENABLED then createESP(p) end
            end)
            if ESP_ENABLED and p.Character then
                createESP(p)
            end
        end

        for _, p in ipairs(Players:GetPlayers()) do
            setupPlayerESP(p)
        end

        Players.PlayerAdded:Connect(setupPlayerESP)
        Players.PlayerRemoving:Connect(removeESP)

--================= æœå‹™ =================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

--================= è®Šæ•¸ =================
local NOCLIP_ENABLED = false
local noclipConn = nil

--================= Noclip æ ¸å¿ƒ =================
local function setNoclipState(state)
    NOCLIP_ENABLED = state

    if state then
        if noclipConn then return end
        noclipConn = RunService.Stepped:Connect(function()
            local char = player.Character
            if not char then return end

            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    else
        if noclipConn then
            noclipConn:Disconnect()
            noclipConn = nil
        end

        local char = player.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
end

-- ================= Water Walk Core =================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

local waterWalkEnabled = false
local platform
local renderConn

local function getHRP()
    return player.Character and player.Character:FindFirstChild("HumanoidRootPart")
end

local function getWaterY()
    local water = Workspace:FindFirstChild("Water")
    return water and water.Position.Y or 0
end

local function createPlatform()
    if platform then platform:Destroy() end

    local hrp = getHRP()
    if not hrp then return end

    platform = Instance.new("Part")
    platform.Name = "WaterWalkPlatform"
    platform.Size = Vector3.new(50, 1, 50)
    platform.Anchored = true
    platform.CanCollide = true
    platform.Transparency = 1
    platform.Parent = Workspace

    platform.Position = Vector3.new(
        hrp.Position.X,
        getWaterY() - 3,
        hrp.Position.Z
    )
end

local function updatePlatform()
    if not platform then return end
    local hrp = getHRP()
    if not hrp then return end

    local waterY = getWaterY()

    if hrp.Position.Y < waterY then
        platform.CanCollide = false
    else
        platform.CanCollide = true
        platform.Position = Vector3.new(
            hrp.Position.X,
            waterY - 3,
            hrp.Position.Z
        )
    end
end

function setWaterWalkState(state)
    waterWalkEnabled = state

    if state then
        createPlatform()
        renderConn = RunService.RenderStepped:Connect(updatePlatform)
    else
        if renderConn then
            renderConn:Disconnect()
            renderConn = nil
        end
        if platform then
            platform:Destroy()
            platform = nil
        end
    end
end

-- æ ¸å¿ƒ Hitbox é‚è¼¯
local Hitbox = {
    Enabled = false,
    Size = 1,
    Transparency = 0.5,
    Connections = {}
}

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local function getRoot(character)
    return character:FindFirstChild("HumanoidRootPart")
end

function Hitbox:ApplyToPlayer(plr)
    if plr == LocalPlayer then return end
    if not plr.Character then return end

    local root = getRoot(plr.Character)
    if root and root:IsA("BasePart") then
        root.CanCollide = false
        root.Size = Vector3.new(self.Size, self.Size, self.Size)
        root.Transparency = self.Transparency
    end
end

function Hitbox:ApplyAll()
    for _, plr in pairs(Players:GetPlayers()) do
        self:ApplyToPlayer(plr)
    end
end

function Hitbox:Start()
    if self.Enabled then return end
    self.Enabled = true

    self:ApplyAll()

    -- ç©å®¶é‡ç”Ÿæ™‚é‡æ–°å¥—ç”¨
    self.Connections.PlayerAdded = Players.PlayerAdded:Connect(function(plr)
        plr.CharacterAdded:Connect(function()
            task.wait(1)
            if self.Enabled then
                self:ApplyToPlayer(plr)
            end
        end)
    end)
end

function Hitbox:Stop()
    self.Enabled = false
end

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local MAX_ZOOM = 10000
local MIN_ZOOM = 1000
local STEP = 100
local CurrentZoom = 1000

-- åˆå§‹åŒ–æ”å½±æ©Ÿç¸®æ”¾
player.CameraMaxZoomDistance = CurrentZoom

-- æ›´æ–°æ”å½±æ©Ÿç¸®æ”¾çš„å‡½æ•¸
local function SetZoom(value)
    value = tonumber(value)
    if not value then return end
    if value < MIN_ZOOM then value = MIN_ZOOM end
    if value > MAX_ZOOM then value = MAX_ZOOM end
    value = math.floor(value / STEP) * STEP
    CurrentZoom = value
    player.CameraMaxZoomDistance = value
end

-- ç›£è½è§’è‰²é‡ç”Ÿ
player.CharacterAdded:Connect(function(char)
    character = char
end)

-- ===== FastAttack æ ¸å¿ƒ =====
_G.FastAttack = true

local Settings = {
    AutoClick = true,
    Distance = 50,
    AttackInterval = 0.01,
    MaxTargets = 20,
}


local function IsAlive(char)
    local hum = char:FindFirstChild("Humanoid")
    return hum and hum.Health > 0
end

local Net = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Net")
local RegisterAttack = Net:WaitForChild("RE/RegisterAttack")
local RegisterHit = Net:WaitForChild("RE/RegisterHit")

local EnemiesFolder = workspace:WaitForChild("Enemies")
local CharactersFolder = workspace:WaitForChild("Characters")

task.spawn(function()
    while true do
        if _G.FastAttack and Settings.AutoClick then
            local char = player.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            if root then
                local targets = {}

                for _, folder in ipairs({EnemiesFolder, CharactersFolder}) do
                    for _, obj in ipairs(folder:GetChildren()) do
                        if obj ~= char and IsAlive(obj) then
                            local head = obj:FindFirstChild("Head")
                            if head then
                                local dist = (head.Position - root.Position).Magnitude
                                if dist <= Settings.Distance then
                                    table.insert(targets, {obj, head})
                                    if #targets >= Settings.MaxTargets then break end
                                end
                            end
                        end
                    end
                    if #targets >= Settings.MaxTargets then break end
                end

                if #targets > 0 then
                    RegisterAttack:FireServer(0)
                    RegisterHit:FireServer(targets[1][2], targets)
                end
            end
        end
        task.wait(Settings.AttackInterval)
    end
end)


local player = Players.LocalPlayer
local ATTACK_INTERVAL = 0.01
local RANGE_MULTIPLIER = 1000

getgenv().AUTO_ATTACK_ENABLED = false

local attackTimer = 0

RunService.Heartbeat:Connect(function(dt)
	if not getgenv().AUTO_ATTACK_ENABLED then return end
	
	local character = player.Character
	if not character then return end

	local tool = character:FindFirstChildOfClass("Tool")
	if not tool then return end

	attackTimer += dt
	if attackTimer < ATTACK_INTERVAL then return end
	attackTimer = 0

	local handle = tool:FindFirstChild("Handle")
	if handle and not handle:GetAttribute("HitboxExpanded") then
		handle.Size = handle.Size * RANGE_MULTIPLIER
		handle.Transparency = 1
		handle.CanCollide = false
		handle:SetAttribute("HitboxExpanded", true)
	end

	tool:Activate()
end)

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

--========================
--        State
--========================
local FlyEnabled = false
local CamlockEnabled = false
local NoclipEnabled = false
local TargetPlayer = nil
local FlySpeed = 350

--========================
--        FLY
--========================
local function EnableFly()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then hum.PlatformStand = true end
end

local function DisableFly()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then hum.PlatformStand = false end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if hrp then hrp.Velocity = Vector3.zero end
end

RunService.RenderStepped:Connect(function()
    if not FlyEnabled or not TargetPlayer then return end
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    local targetChar = TargetPlayer.Character
    local targetHRP = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
    if not hrp or not targetHRP then return end
    local direction = (targetHRP.Position - hrp.Position)
    if direction.Magnitude > 0 then
        hrp.Velocity = direction.Unit * FlySpeed
    end
end)

--========================
--       NOCLIP
--========================
RunService.Stepped:Connect(function()
    if not NoclipEnabled then return end
    local char = LocalPlayer.Character
    if not char then return end
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end)

--========================
--       CAMLOCK
--========================
RunService.RenderStepped:Connect(function()
    if not CamlockEnabled or not TargetPlayer then return end
    if not TargetPlayer.Character then return end
    local hrp = TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    Camera.CFrame = CFrame.new(Camera.CFrame.Position, hrp.Position)
end)

local selectedType = "Melee"   -- åˆå§‹é¸æ“‡æ­¦å™¨é¡å‹
local autoEquipEnabled = false

local function equipByType(toolType)
    selectedType = toolType
    if autoEquipEnabled then
        local char = player.Character or player.CharacterAdded:Wait()
        local hum = char:WaitForChild("Humanoid")
        for _, tool in ipairs(player.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.ToolTip == toolType then
                hum:EquipTool(tool)
                break
            end
        end
    end
end

local function monitorCurrentTool()
    task.spawn(function()
        while true do
            task.wait(0.1)
            if autoEquipEnabled then
                local char = player.Character
                if char then
                    local hum = char:FindFirstChildOfClass("Humanoid")
                    if hum then
                        local tool = hum:FindFirstChildOfClass("Tool")
                        if not tool or tool.ToolTip ~= selectedType then
                            equipByType(selectedType)
                        end
                    end
                end
            end
        end
    end)
end

player.CharacterAdded:Connect(function()
    task.wait(1)
    equipByType(selectedType)
    monitorCurrentTool()
end)

monitorCurrentTool()

-- ===== Fly + Bring æ ¸å¿ƒç‹€æ…‹ =====
local FlyTP = {
    Enabled = false,
    HoverHeight = 10,
    SearchRange = 500
}

local BringNPC = {
    Enabled = false,
    PullRange = 100
}

local flyConn
local pullConn
local targetNPC

local function stopFly()
    if flyConn then
        flyConn:Disconnect()
        flyConn = nil
    end
    FlyTP.Enabled = false
end

local function startFly()
    if flyConn then return end

    flyConn = RunService.Heartbeat:Connect(function()
        if not FlyTP.Enabled then return end

        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local enemiesFolder = workspace:FindFirstChild("Enemies")
        if not enemiesFolder then return end

        local closest, dist = nil, math.huge

        for _, npc in pairs(enemiesFolder:GetChildren()) do
            if npc:FindFirstChild("Humanoid")
                and npc.Humanoid.Health > 0
                and npc.PrimaryPart then

                local p = npc.PrimaryPart.Position
                local d = (p - hrp.Position).Magnitude

                if d < dist and d <= FlyTP.SearchRange then
                    dist = d
                    closest = npc
                end
            end
        end

        targetNPC = closest

        if targetNPC and targetNPC.PrimaryPart then
            local tpos = Vector3.new(
                targetNPC.PrimaryPart.Position.X,
                targetNPC.PrimaryPart.Position.Y + FlyTP.HoverHeight,
                targetNPC.PrimaryPart.Position.Z
            )
            hrp.CFrame = CFrame.new(tpos)
        end
    end)
end

local function stopBring()
    if pullConn then
        pullConn:Disconnect()
        pullConn = nil
    end
    BringNPC.Enabled = false
end

local function startBring()
    if pullConn then return end

    pullConn = RunService.Heartbeat:Connect(function()
        if not BringNPC.Enabled then return end
        if not targetNPC or not targetNPC.PrimaryPart then return end

        local enemiesFolder = workspace:FindFirstChild("Enemies")
        if not enemiesFolder then return end

        local basePos = targetNPC.PrimaryPart.Position

        for _, npc in pairs(enemiesFolder:GetChildren()) do
            if npc ~= targetNPC
                and npc:FindFirstChild("Humanoid")
                and npc.Humanoid.Health > 0
                and npc.PrimaryPart then

                local dist = (npc.PrimaryPart.Position - basePos).Magnitude

                if dist <= BringNPC.PullRange then
                    local newPos = Vector3.new(
                        basePos.X,
                        npc.PrimaryPart.Position.Y,
                        basePos.Z
                    )
                    npc:SetPrimaryPartCFrame(CFrame.new(newPos))
                end
            end
        end
    end)
end

--==================================================
-- Config / State
--==================================================
local CHECK_INTERVAL = 1
local DETECTION_RADIUS = 1000
local AutoTeleportEnabled = false
local isTeleporting = false

local hrp, humanoid

--==================================================
-- Helper Functions
--==================================================
local function getCharacterParts()
    local char = game.Players.LocalPlayer.Character
    if not char then return nil end
    hrp = char:FindFirstChild("HumanoidRootPart")
    humanoid = char:FindFirstChild("Humanoid")
    if hrp and humanoid then
        return true
    end
    return false
end

local function enemiesAlive()
    local enemies = workspace:FindFirstChild("Enemies")
    if not enemies then return false end
    for _, npc in ipairs(enemies:GetChildren()) do
        local hum = npc:FindFirstChild("Humanoid")
        local root = npc:FindFirstChild("HumanoidRootPart") or npc:FindFirstChild("Head")
        if hum and hum.Health > 0 and root and hrp then
            if (root.Position - hrp.Position).Magnitude <= DETECTION_RADIUS then
                return true
            end
        end
    end
    return false
end

local function bossAlive()
    local boss = workspace:FindFirstChild("Boss")
    if boss and boss:FindFirstChild("Humanoid") and boss.Humanoid.Health > 0 then
        return true
    end
    local enemies = workspace:FindFirstChild("Enemies")
    if enemies then
        for _, npc in ipairs(enemies:GetChildren()) do
            if string.find(string.lower(npc.Name), "boss") then
                local hum = npc:FindFirstChild("Humanoid")
                if hum and hum.Health > 0 then
                    return true
                end
            end
        end
    end
    return false
end

local function canTeleport()
    return not enemiesAlive() and not bossAlive()
end

local function getClosestExit()
    local map = workspace:FindFirstChild("Map")
    if not map then return nil end
    local dungeon = map:FindFirstChild("Dungeon")
    if not dungeon then return nil end

    local closest, minDist = nil, math.huge
    for _, f in ipairs(dungeon:GetChildren()) do
        if tonumber(f.Name) then
            local tp = f:FindFirstChild("ExitTeleporter")
            if tp and tp:FindFirstChild("Root") then
                local d = (tp.Root.Position - hrp.Position).Magnitude
                if d < minDist then
                    minDist = d
                    closest = tp.Root
                end
            end
        end
    end
    return closest
end

local function teleportToExit(exitRoot)
    if isTeleporting or not exitRoot then return end
    isTeleporting = true
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    hrp.CFrame = exitRoot.CFrame
    humanoid.WalkSpeed = 16
    humanoid.JumpPower = 50
    isTeleporting = false
end

--==================================================
-- Auto-Teleport Loop
--==================================================
task.spawn(function()
    while task.wait(CHECK_INTERVAL) do
        if not AutoTeleportEnabled then continue end
        if not getCharacterParts() or humanoid.Health <= 0 then continue end
        if canTeleport() then
            local exit = getClosestExit()
            if exit then
                teleportToExit(exit)
            end
        end
    end
end)

-- ================= æ ¸å¿ƒåƒæ•¸ =================
local SLIDE_MAGNITUDE = 200
local ACCELERATION = 12
local DECELERATION = 18
local MAX_SPEED = 1000

local moving = false
local moveConn
local moveKeys = {W=false, A=false, S=false, D=false}
local currentVelocity = Vector3.zero
local wasMoving = false -- åŸæœ¬æ»‘å‹•ç‹€æ…‹
local slideLocked = false -- ä¸Šèˆ¹é–å®šæ»‘å‹•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character, root, humanoid

-- ================= æ ¸å¿ƒå‡½æ•¸ =================
local function setupCharacter(char)
    character = char
    root = char:WaitForChild("HumanoidRootPart")
    humanoid = char:WaitForChild("Humanoid")
end
setupCharacter(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(setupCharacter)

-- ================= WASD æ§åˆ¶ =================
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.W then moveKeys.W = true end
    if input.KeyCode == Enum.KeyCode.A then moveKeys.A = true end
    if input.KeyCode == Enum.KeyCode.S then moveKeys.S = true end
    if input.KeyCode == Enum.KeyCode.D then moveKeys.D = true end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then moveKeys.W = false end
    if input.KeyCode == Enum.KeyCode.A then moveKeys.A = false end
    if input.KeyCode == Enum.KeyCode.S then moveKeys.S = false end
    if input.KeyCode == Enum.KeyCode.D then moveKeys.D = false end
end)

-- ================= ç§»å‹•æ ¸å¿ƒ =================
local function startMove()
    if moving or not root or slideLocked then return end
    moving = true
    wasMoving = true

    moveConn = RunService.RenderStepped:Connect(function(dt)
        if not root or ACTIVE_SEAT then return end
        if slideLocked then return end

        local cam = Workspace.CurrentCamera
        local look = Vector3.new(cam.CFrame.LookVector.X,0,cam.CFrame.LookVector.Z)
        local right = Vector3.new(cam.CFrame.RightVector.X,0,cam.CFrame.RightVector.Z)

        local dir = Vector3.zero
        if moveKeys.W then dir += look end
        if moveKeys.S then dir -= look end
        if moveKeys.A then dir -= right end
        if moveKeys.D then dir += right end
        if dir.Magnitude > 0 then dir = dir.Unit end

        local targetVelocity = dir * SLIDE_MAGNITUDE
        local lerpSpeed = dir.Magnitude > 0 and ACCELERATION or DECELERATION
        currentVelocity = currentVelocity:Lerp(targetVelocity, math.clamp(lerpSpeed*dt,0,1))

        root.CFrame += Vector3.new(currentVelocity.X,0,currentVelocity.Z) * dt
    end)
end

local function stopMove()
    moving = false
    if moveConn then
        moveConn:Disconnect()
        moveConn = nil
    end
end

local function toggleMove(state)
    if slideLocked and state then return end
    if state then
        startMove()
    else
        stopMove()
        wasMoving = false
        currentVelocity = Vector3.zero
    end
end

-- ================= èˆ¹é€Ÿç³»çµ± =================
local BoatSpeedSettings = {
    Enabled = false,
    Speed = 200,
    MaxSpeed = 500
}
local ACTIVE_SEAT = nil
local ORIGINAL_SEAT_SPEED = nil

local function updateBoatSpeed()
    if not ACTIVE_SEAT then return end
    if BoatSpeedSettings.Enabled then
        ACTIVE_SEAT.MaxSpeed = BoatSpeedSettings.Speed
    elseif ORIGINAL_SEAT_SPEED then
        ACTIVE_SEAT.MaxSpeed = ORIGINAL_SEAT_SPEED
    end
end

-- ================= èˆ¹åº§ç›£è½ =================
local function onCharacter(char)
    local hum = char:WaitForChild("Humanoid")
    hum.Seated:Connect(function(sitting, seat)
        if seat and seat:IsA("VehicleSeat") and sitting then
            slideLocked = true
            if moving then stopMove() end

            ACTIVE_SEAT = seat
            ORIGINAL_SEAT_SPEED = seat.MaxSpeed
            updateBoatSpeed()
        else
            slideLocked = false
            if ACTIVE_SEAT and ORIGINAL_SEAT_SPEED then
                ACTIVE_SEAT.MaxSpeed = ORIGINAL_SEAT_SPEED
            end
            ACTIVE_SEAT = nil
            ORIGINAL_SEAT_SPEED = nil

            if wasMoving then
                startMove()
            else
                currentVelocity = Vector3.zero
            end
        end
    end)
end

if player.Character then onCharacter(player.Character) end
player.CharacterAdded:Connect(onCharacter)

-- è‡ªå‹•å•Ÿç”¨ AutoBuso
AutoBuso = true
if AutoBuso then
    pcall(function()
        if Player.Character and not Player.Character:FindFirstChild("HasBuso") then
            CommF:InvokeServer("Buso")
        end
    end)
end

-- è‡ªå‹•æ­¦è£è‰²é‚è¼¯å¾ªç’°
task.spawn(function()
    while task.wait(1) do
        if AutoBuso then
            pcall(function()
                if Player.Character and not Player.Character:FindFirstChild("HasBuso") then
                    CommF:InvokeServer("Buso")
                end
            end)
        end
    end
end)

local VirtualInputManager = game:GetService("VirtualInputManager")

local AutoV3 = {
    Enabled = false,
    _task = nil
}

local function StartAutoV3()
    if AutoV3._task then return end

    AutoV3._task = task.spawn(function()
        while AutoV3.Enabled do
            -- æŒ‰ä¸‹ T
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.T, false, game)
            task.wait(0.01)
            -- æ”¾é–‹ T
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.T, false, game)
            task.wait(0.1)
        end
        AutoV3._task = nil
    end)
end

local function StopAutoV3()
    AutoV3.Enabled = false
end

--// ç‹€æ…‹
local AutoV4 = false
local autoV4Connection = nil

-- ================= å–å¾— Awakening RemoteFunction =================
local function getAwakeningRemote()
    local backpack = Player:FindFirstChild("Backpack")
    if backpack then
        local awakening = backpack:FindFirstChild("Awakening")
        if awakening then
            return awakening:FindFirstChild("RemoteFunction")
        end
    end
    return nil
end

local LOWGRAPHICS_ENABLED = false
local Terrain = workspace:FindFirstChildWhichIsA("Terrain")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local function ApplyLowGraphics(state)
    LOWGRAPHICS_ENABLED = state

    if state then
        -- Terrain
        Terrain.WaterWaveSize = 0
        Terrain.WaterWaveSpeed = 0
        Terrain.WaterReflectance = 0
        Terrain.WaterTransparency = 1
        
        -- Lighting
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 9e9
        Lighting.FogStart = 9e9

        -- Render Quality
        settings().Rendering.QualityLevel = 1

        -- éæ­·éŠæˆ²ç‰©ä»¶
        for _, v in pairs(game:GetDescendants()) do
            if v:IsA("BasePart") then
                v.CastShadow = false
                v.Material = Enum.Material.Plastic
                v.Reflectance = 0
            elseif v:IsA("Decal") then
                v.Transparency = 1
                v.Texture = ""
            elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                v.Lifetime = NumberRange.new(0)
            end
        end

        -- é—œé–‰å¾Œè™•ç†æ•ˆæœ
        for _, v in pairs(Lighting:GetDescendants()) do
            if v:IsA("PostEffect") then
                v.Enabled = false
            end
        end

        -- è‡ªå‹•åˆªé™¤æ–°å¢ç‰¹æ•ˆ
        workspace.DescendantAdded:Connect(function(child)
            task.spawn(function()
                if child:IsA("ForceField") 
                or child:IsA("Sparkles") 
                or child:IsA("Smoke") 
                or child:IsA("Fire") 
                or child:IsA("Beam") then
                    RunService.Heartbeat:Wait()
                    child:Destroy()
                elseif child:IsA("BasePart") then
                    child.CastShadow = false
                end
            end)
        end)
    else
        -- å¯é¸ï¼šæ¢å¾©ä½é…æ¨¡å¼å‰çš„ç‹€æ…‹
        Lighting.GlobalShadows = true
    end
end

-- =====================
-- Remove Fog Core
-- =====================
local function RemoveFog()
    local Lighting = game:GetService("Lighting")

    -- ç§»é™¤ LightingLayers
    local layers = Lighting:FindFirstChild("LightingLayers")
    if layers then
        layers:Destroy()
    end

    -- ç§»é™¤ Sky
    local sky = Lighting:FindFirstChildOfClass("Sky")
    if sky then
        sky:Destroy()
    end

    -- é—œé–‰éœ§æ°£
    Lighting.FogEnd = 9e9
end

local AntiAFK_ENABLED = false
local AntiAFK_Connection

local function EnableAntiAFK()
    if AntiAFK_ENABLED then return end
    AntiAFK_ENABLED = true

    if getconnections then
        for _, connection in pairs(getconnections(Players.LocalPlayer.Idled)) do
            if connection.Disable then
                connection:Disable()
            elseif connection.Disconnect then
                connection:Disconnect()
            end
        end
    else
        AntiAFK_Connection = Players.LocalPlayer.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end

    print("Anti-AFK ON")
end

local function DisableAntiAFK()
    if not AntiAFK_ENABLED then return end
    AntiAFK_ENABLED = false

    if AntiAFK_Connection then
        AntiAFK_Connection:Disconnect()
        AntiAFK_Connection = nil
    end

    print("Anti-AFK OFF")
end

-- â­ é€²å…¥éŠæˆ²å°±å•Ÿç”¨
EnableAntiAFK()

local JumpSettings = {
    Enabled = false,
    JumpPower = 100,
    MaxJumpPower = 500
}

local function updateJumpPower()
    local character = LocalPlayer.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    if humanoid.UseJumpPower then
        humanoid.JumpPower = JumpSettings.Enabled and JumpSettings.JumpPower or 50
    else
        humanoid.JumpHeight = JumpSettings.Enabled and JumpSettings.JumpPower or 7.2
    end
end

-- è§’è‰²é‡ç”Ÿæ™‚è‡ªå‹•å¥—ç”¨
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    updateJumpPower()
end)

-- æ ¸å¿ƒåŠŸèƒ½ï¼šç§»é™¤ Lava
local function removeLava()
    for _, v in pairs(game.Workspace:GetDescendants()) do
        if v.Name == "LavaParts" and v.Parent and v.Parent.Name == "CircleIsland" 
            and v.Parent.Parent and v.Parent.Parent.Name == "Map" then
            v:Destroy()
        end
    end

    for _, v in pairs(game.ReplicatedStorage:GetDescendants()) do
        if v.Name == "LavaParts" and v.Parent and v.Parent.Name == "CircleIsland" 
            and v.Parent.Parent and v.Parent.Parent.Name == "Map" then
            v:Destroy()
        end
    end
end

local Tabs = {
    General  = Window:Tab({ Title = "é€šç”¨",   Icon = "house" }),
    Server   = Window:Tab({ Title = "Server", Icon = "server" }),
    Status   = Window:Tab({ Title = "ç‹€æ…‹",   Icon = "activity" }),
    PVP      = Window:Tab({ Title = "PVP",    Icon = "swords" }),
    Farm     = Window:Tab({ Title = "Farm",   Icon = "leaf" }),
    Auto     = Window:Tab({ Title = "è‡ªå‹•",   Icon = "cpu" }),
    Settings = Window:Tab({ Title = "è¨­å®š",   Icon = "settings" }),
    Teleport = Window:Tab({ Title = "å‚³é€",   Icon = "map-pin" }),
    Fun      = Window:Tab({ Title = "å¨›æ¨‚",   Icon = "smile" }),
    Other    = Window:Tab({ Title = "å…¶ä»–",   Icon = "ellipsis" }),
}

Tabs.General:Section({ Title = "é€šç”¨" })

Tabs.General:Toggle({
    Title = "ESP",
    Desc = "é¡¯ç¤ºç©å®¶åç¨±ã€è¡€é‡èˆ‡è·é›¢",
    Value = false,
    Callback = function(state)
        ESP_ENABLED = state

        for _, p in ipairs(Players:GetPlayers()) do
            if ESP_ENABLED then
                createESP(p)
            else
                removeESP(p)
            end
        end
    end
})

Tabs.General:Toggle({
    Title = "Noclip",
    Desc = "è§’è‰²å¯ç©¿ç‰†ç§»å‹•",
    Value = false,
    Callback = function(state)
        setNoclipState(state)
    end
})

-- ================= Wind UI Toggle =================
Tabs.General:Toggle({
    Title = "æ°´ä¸Šè¡Œèµ°",
    Desc = "å¯åœ¨æ°´é¢ä¸Šè¡Œèµ°",
    Value = false,
    Callback = function(state)
        setWaterWalkState(state)
    end
})

Tabs.General:Button({
    Title = "Remove Lava",
    Desc = "æŒ‰ä¸€æ¬¡è§¸ç™¼",
    Callback = function()
        -- å¯åŠ ä¸Šç°¡å–®å‹•ç•«æ•ˆæœï¼ˆé¸æ“‡æ€§ï¼‰
        local TweenService = game:GetService("TweenService")

        -- å‘¼å«æ ¸å¿ƒåŠŸèƒ½
        removeLava()
    end
})

Tabs.General:Slider({
    Title = "ç¢°æ’ç®±",
    Desc = "èª¿æ•´ç¢°æ’ç®±å¤§å°",
    Value = {
        Min = 1,
        Max = 20,
        Default = Hitbox.Size
    },
    Callback = function(value)
        Hitbox.Size = value
        Hitbox:ApplyAll()
    end
})

Tabs.General:Slider({
    Title = "è¦–è§’ç¸®æ”¾",
    Desc = "èª¿æ•´è¦–è§’è·é›¢",
    Value = {
        Min = MIN_ZOOM,
        Max = MAX_ZOOM,
        Default = CurrentZoom
    },
    Callback = function(value)
        -- æŒ‰æ­¥é€²è¨ˆç®—æœ€æ¥è¿‘çš„å€¼
        local zoomValue = math.floor(value / STEP) * STEP
        SetZoom(zoomValue)
        print("Camera Zoom:", zoomValue)
    end
})

Tabs.Server:Section({ Title = "Server" })
-- ===== åˆ‡æ›ä¼ºæœå™¨ =====
Tabs.Server:Button({
    Title = "åˆ‡æ›ä¼ºæœå™¨",
    Callback = function()
        task.spawn(function()
            pcall(function()
                TeleportService:Teleport(PlaceId, LocalPlayer)
            end)
        end)
        WindUI:Notify({
            Title = "å‚³é€ä¸­",
            Content = "æ­£åœ¨åˆ‡æ›ä¼ºæœå™¨...",
            Duration = 3
        })
    end
})

-- ===== é‡é€²ä¼ºæœå™¨ =====
Tabs.Server:Button({
    Title = "é‡é€²ä¼ºæœå™¨",
    Callback = function()
        task.spawn(function()
            TeleportService:Teleport(PlaceId, LocalPlayer)
        end)
        WindUI:Notify({
            Title = "é‡é€²ä¼ºæœå™¨",
            Content = "ä½ å·²ç¶“é‡æ–°é€²å…¥åŒä¸€ä¼ºæœå™¨",
            Duration = 3
        })
    end
})

-- ===== åŠ å…¥å°‘äººä¼ºæœå™¨ =====
Tabs.Server:Button({
    Title = "åŠ å…¥å°‘äººä¼ºæœå™¨",
    Callback = function()
        task.spawn(function()
            local AllServers = {}
            local success, servers = pcall(function()
                return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..PlaceId.."/servers/Public?sortOrder=Asc&limit=100"))
            end)
            if success and servers and servers.data then
                for _, s in ipairs(servers.data) do
                    if s.id ~= game.JobId and s.playing < s.maxPlayers then
                        table.insert(AllServers, s.id)
                    end
                end
            end
            if #AllServers > 0 then
                local randId = AllServers[math.random(1,#AllServers)]
                TeleportService:TeleportToPlaceInstance(PlaceId, randId, LocalPlayer)
            end
        end)
        WindUI:Notify({
            Title = "å‚³é€åˆ°å°‘äººä¼ºæœå™¨",
            Content = "æ­£åœ¨å°‹æ‰¾ç©å®¶è¼ƒå°‘çš„ä¼ºæœå™¨...",
            Duration = 3
        })
    end
})

Tabs.Status:Section({ Title = "ç‹€æ…‹" })

Tabs.PVP:Section({ Title = "PVP" })

Tabs.PVP:Toggle({
    Title = "è‡ªå‹•æ”»æ“Š",
    Desc = "FastAttack é–‹é—œ",
    Value = true,
    Callback = function(state)
        _G.FastAttack = state
        Settings.AutoClick = state
    end
})

Tabs.PVP:Slider({
    Title = "æ”»æ“Šè·é›¢",
    Desc = "èª¿æ•´æ”»æ“Šè·é›¢",
    Value = {
        Min = 0,
        Max = 1000,
        Default = 50
    },
    Callback = function(value)
        Settings.Distance = value
    end
})

Tabs.PVP:Toggle({
    Title = "Fruit M1",
    Desc = "é–‹å•Ÿæˆ–é—œé–‰æœå¯¦è‡ªå‹•æ™®æ”»",
    Value = false,
    Callback = function(state)
        getgenv().AUTO_ATTACK_ENABLED = state
        
        print("Auto Attack State:", state)
    end
})


local function GetPlayerList()
    local list = {}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            table.insert(list, plr.Name)
        end
    end
    return list
end

-- ç©å®¶ Dropdown
local playerDropdown = Tabs.PVP:Dropdown({
    Title = "é¸æ“‡ç©å®¶",
    Values = GetPlayerList(),
    Value = nil,
    Callback = function(option)
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr.Name == option then
                TargetPlayer = plr
                break
            end
        end
    end
})

-- è‡ªå‹•æ›´æ–°ç©å®¶åˆ—è¡¨
Players.PlayerAdded:Connect(function()
    playerDropdown:Refresh(GetPlayerList())
end)
Players.PlayerRemoving:Connect(function()
    playerDropdown:Refresh(GetPlayerList())
end)

Tabs.PVP:Toggle({
    Title = "Fly to Player",
    Desc = "é£›å‘é¸å®šç©å®¶",
    Value = false,
    Callback = function(state)
        FlyEnabled = state
        NoclipEnabled = state
        if state then EnableFly() else DisableFly() end
    end
})

Tabs.PVP:Toggle({
    Title = "è¦–è§’é–å®š",
    Desc = "é–å®šç›®æ¨™ç©å®¶",
    Value = false,
    Callback = function(state)
        CamlockEnabled = state
    end
})

Tabs.Farm:Section({ Title = "Farm Setting" })

Tabs.Farm:Dropdown({
    Title = "é¸æ“‡é…ç½®",
    Multi = false,
    Values = { "Melee", "Blox Fruit", "Sword", "Gun" },
    Default = "Melee",
    Callback = function(option)
        selectedType = option
        if autoEquipEnabled then
            equipByType(selectedType)
        end
    end
})

Tabs.Farm:Toggle({
    Title = "è‡ªå‹•è£å‚™",
    Desc = "è‡ªå‹•åˆ‡æ›åˆ°é¸æ“‡çš„é…ç½®",
    Value = false,
    Callback = function(state)
        autoEquipEnabled = state
        if state then
            equipByType(selectedType)
        end
    end
})

Tabs.Farm:Toggle({
    Title = "TP to NPC",
    Desc = "è‡ªå‹•å‚³é€åˆ°NPC",
    Value = FlyTP.Enabled,
    Callback = function(state)
        FlyTP.Enabled = state
        if state then
            startFly()
        else
            stopFly()
        end
    end
})

Tabs.Farm:Toggle({
    Title = "Bring NPC",
    Desc = "æŠŠé™„è¿‘NPCå¸¶éä¾†",
    Value = BringNPC.Enabled,
    Callback = function(state)
        BringNPC.Enabled = state
        if state then
            startBring()
        else
            stopBring()
        end
    end
})

Tabs.Farm:Slider({
    Title = "é£›è¡Œé«˜åº¦",
    Desc = "èª¿æ•´é£›è¡Œé«˜åº¦ (50m)",
    Value = {
        Min = 0,
        Max = 50,
        Default = FlyTP.HoverHeight
    },
    Callback = function(value)
        FlyTP.HoverHeight = value
    end
})

Tabs.Farm:Slider({
    Title = "æœå°‹ç¯„åœ",
    Desc = "èª¿æ•´NPCæœå°‹ç¯„åœ (2000m)",
    Value = {
        Min = 0,
        Max = 2000,
        Default = FlyTP.SearchRange
    },
    Callback = function(value)
        FlyTP.SearchRange = value
    end
})

Tabs.Farm:Slider({
    Title = "æ‹‰æ€ªç¯„åœ",
    Desc = "èª¿æ•´æ‹‰æ€ªè·é›¢ (250)m)",
    Value = {
        Min = 0,
        Max = 250,
        Default = BringNPC.PullRange
    },
    Callback = function(value)
        BringNPC.PullRange = value
    end
})

Tabs.Farm:Section({ Title = "Dungeon" })

Tabs.Farm:Toggle({
    Title = "è‡ªå‹•å‚³é€",
    Desc = "è‡ªå‹•å‚³é€åˆ°å‡ºå£",
    Value = false,
    Callback = function(state)
        AutoTeleportEnabled = state

        -- é–‹å•Ÿæ™‚ç«‹å³æª¢æŸ¥æ˜¯å¦å¯ä»¥å‚³é€
        if AutoTeleportEnabled and getCharacterParts() and canTeleport() then
            local exit = getClosestExit()
            if exit then
                teleportToExit(exit)
            end
        end
    end
})

Tabs.Farm:Section({ Title = "èˆ¹" })

Tabs.Farm:Toggle({
    Title = "èˆ¹éš»åŠ é€Ÿ",
    Desc = "å•Ÿç”¨æˆ–é—œé–‰èˆ¹é€Ÿåº¦ä¿®æ”¹",
    Value = BoatSpeedSettings.Enabled,
    Callback = function(state)
        BoatSpeedSettings.Enabled = state
        updateBoatSpeed()
    end
})

Tabs.Farm:Slider({
    Title = "èˆ¹é€Ÿèª¿æ•´",
    Desc = "èª¿æ•´èˆ¹æœ€å¤§é€Ÿåº¦",
    Value = {
        Min = 0,
        Max = BoatSpeedSettings.MaxSpeed,
        Default = BoatSpeedSettings.Speed
    },
    Callback = function(value)
        BoatSpeedSettings.Speed = value
        updateBoatSpeed()
    end
})

Tabs.Auto:Section({ Title = "è‡ªå‹•" })

Tabs.Auto:Toggle({
    Title = "è‡ªå‹•æ­¦è£è‰²",
    Desc = "è‡ªå‹•é–‹å•Ÿæˆ–é—œé–‰æ­¦è£è‰²",
    Value = true, -- åˆå§‹ç‚º ON
    Callback = function(state)
        AutoBuso = state
        print("AutoBuso ç‹€æ…‹:", AutoBuso)

        -- åˆå§‹å•Ÿå‹•æ™‚ç«‹å³å‘¼å«ä¸€æ¬¡
        if AutoBuso then
            pcall(function()
                if Player.Character and not Player.Character:FindFirstChild("HasBuso") then
                    CommF:InvokeServer("Buso")
                end
            end)
        end
    end
})

Tabs.Auto:Toggle({
    Title = "è‡ªå‹• v3",
    Desc = "è‡ªå‹•é–‹å•Ÿæˆ–é—œé–‰v3",
    Value = false, -- åˆå§‹ç‚º OFF
    Callback = function(state)
        AutoV3.Enabled = state
        print("è‡ªå‹• v3 ç‹€æ…‹:", state)

        if state then
            StartAutoV3()
        else
            StopAutoV3()
        end
    end
})

Tabs.Auto:Toggle({
    Title = "è‡ªå‹• V4",
    Desc = "è‡ªå‹•é–‹å•Ÿæˆ–é—œé–‰v4",
    Value = false, -- åˆå§‹é—œé–‰
    Callback = function(state)
        AutoV4 = state
        print("è‡ªå‹• v4 ç‹€æ…‹:", AutoV4)

        -- é—œé–‰æ™‚ä¸­æ–·èˆŠé€£ç·š
        if autoV4Connection then
            autoV4Connection:Disconnect()
            autoV4Connection = nil
        end

        -- é–‹å•Ÿè‡ªå‹• V4
        if AutoV4 then
            -- ç«‹å³å‘¼å«ä¸€æ¬¡
            pcall(function()
                local remote = getAwakeningRemote()
                if remote then
                    remote:InvokeServer(true)
                end
            end)

            -- Heartbeat æŒçºŒå‘¼å«
            autoV4Connection = RunService.Heartbeat:Connect(function()
                local remote = getAwakeningRemote()
                if remote then
                    pcall(function()
                        remote:InvokeServer(true)
                    end)
                end
            end)
        end
    end
})

Tabs.Settings:Section({ Title = "è¨­å®š" })

-- Keybind æŒ‰éˆ•ï¼Œå¯æ”¹è®Š UI é–‹å•Ÿå¿«æ·éµ
local Keybind = Tabs.Settings:Keybind({
    Title = "å¿«æ·éµ",
    Desc = "å¯æ›´æ”¹",
    Value = "G", -- é è¨­æŒ‰éµ
    Callback = function(v)
        -- Enum.KeyCode[v] å¯å°‡å­—æ¯è½‰ç‚º Roblox KeyCode
        Window:SetToggleKey(Enum.KeyCode[v])
        print("UI é–‹å•Ÿå¿«æ·éµå·²è¨­å®šç‚º:", v)
    end
})

Tabs.Settings:Section({ Title = "æé«˜FPS" })

Tabs.Settings:Button({
    Title = "ä½é…æ¨¡å¼",
    Desc = "æŒ‰ä¸€æ¬¡å•Ÿç”¨ä½é…æ¨¡å¼",
    Callback = function()
        ApplyLowGraphics(true)
        print("ä½é…æ¨¡å¼å·²å•Ÿç”¨")
    end
})

Tabs.Settings:Button({
    Title = "Remove Fog",
    Desc = "æŒ‰ä¸€æ¬¡å•Ÿç”¨Remove Fog",
    Callback = function()
        RemoveFog()
    end
})

Tabs.Settings:Section({ Title = "éŠæˆ²å…§" })

Tabs.Settings:Toggle({
    Title = "Anti AFK",
    Desc = "é˜²æ­¢é–’ç½®è¢«è¸¢å‡º",
    Value = true, -- â­ åˆå§‹ç‚º ON
    Callback = function(state)
        if state then
            EnableAntiAFK()
        else
            DisableAntiAFK()
        end
    end
})

Tabs.Settings:Toggle({
    Title = "ç§»å‹•é€Ÿåº¦",
    Desc = "é–‹å•Ÿæˆ–é—œé–‰ WASD ç§»å‹•æ»‘å‹•",
    Value = false,
    Callback = function(state)
        toggleMove(state)
    end
})

Tabs.Settings:Slider({
    Title = "é€Ÿåº¦èª¿æ•´",
    Desc = "èª¿æ•´è§’è‰²æ»‘å‹•é€Ÿåº¦",
    Value = {
        Min = 0,
        Max = 1000,
        Default = SLIDE_MAGNITUDE
    },
    Callback = function(value)
        SLIDE_MAGNITUDE = value
    end
})

Tabs.Settings:Toggle({
    Title = "è·³èºé–‹é—œ",
    Desc = "é–‹å•Ÿæˆ–é—œé–‰è‡ªè¨‚è·³èºé«˜åº¦",
    Value = JumpSettings.Enabled,
    Callback = function(state)
        JumpSettings.Enabled = state
        updateJumpPower()
    end
})

Tabs.Settings:Slider({
    Title = "è·³èºé«˜åº¦",
    Desc = "èª¿æ•´è·³èºé«˜åº¦ï¼ˆ0 ~ 500ï¼‰",
    Value = {
        Min = 0,
        Max = JumpSettings.MaxJumpPower,
        Default = JumpSettings.JumpPower
    },
    Callback = function(value)
        JumpSettings.JumpPower = value
        updateJumpPower()
    end
})

Tabs.Teleport:Section({ Title = "å‚³é€" })

Tabs.Fun:Section({ Title = "å¨›æ¨‚" })

Tabs.Other:Section({ Title = "å…¶ä»–" })
